drop policy "users can view their data / admin view all" on "public"."mindmaps";

create table "public"."mindmap_shares" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "shared_with" uuid,
    "mindmap_id" bigint
);


alter table "public"."mindmap_shares" enable row level security;

alter table "public"."user_profiles" alter column "credit_balance" set default '100'::numeric;

alter table "public"."user_roles" add column "email" text;

CREATE UNIQUE INDEX mindmap_shares_pkey ON public.mindmap_shares USING btree (id);

alter table "public"."mindmap_shares" add constraint "mindmap_shares_pkey" PRIMARY KEY using index "mindmap_shares_pkey";

alter table "public"."mindmap_shares" add constraint "mindmap_shares_mindmap_id_fkey" FOREIGN KEY (mindmap_id) REFERENCES mindmaps(id) ON DELETE CASCADE not valid;

alter table "public"."mindmap_shares" validate constraint "mindmap_shares_mindmap_id_fkey";

alter table "public"."mindmap_shares" add constraint "mindmap_shares_shared_with_fkey" FOREIGN KEY (shared_with) REFERENCES user_profiles(user_id) ON DELETE CASCADE not valid;

alter table "public"."mindmap_shares" validate constraint "mindmap_shares_shared_with_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$BEGIN
  INSERT INTO public.user_profiles (
    user_id,
    email,
    username,
    avatar_url,
    phone
  )
  VALUES (
    new.id,
    new.email,
    COALESCE(
      new.raw_user_meta_data->>'full_name',
      COALESCE(
        new.raw_user_meta_data->>'username',' '
      )
    ),
    COALESCE(new.raw_user_meta_data->>'avatar_url', ''),
    COALESCE(new.phone, '')
  ); 

  INSERT INTO public.user_roles (
    user_id, email
      )
  VALUES (
    new.id,
    new.email
  ); 

  RETURN new;
END;$function$
;

grant delete on table "public"."mindmap_shares" to "anon";

grant insert on table "public"."mindmap_shares" to "anon";

grant references on table "public"."mindmap_shares" to "anon";

grant select on table "public"."mindmap_shares" to "anon";

grant trigger on table "public"."mindmap_shares" to "anon";

grant truncate on table "public"."mindmap_shares" to "anon";

grant update on table "public"."mindmap_shares" to "anon";

grant delete on table "public"."mindmap_shares" to "authenticated";

grant insert on table "public"."mindmap_shares" to "authenticated";

grant references on table "public"."mindmap_shares" to "authenticated";

grant select on table "public"."mindmap_shares" to "authenticated";

grant trigger on table "public"."mindmap_shares" to "authenticated";

grant truncate on table "public"."mindmap_shares" to "authenticated";

grant update on table "public"."mindmap_shares" to "authenticated";

grant delete on table "public"."mindmap_shares" to "service_role";

grant insert on table "public"."mindmap_shares" to "service_role";

grant references on table "public"."mindmap_shares" to "service_role";

grant select on table "public"."mindmap_shares" to "service_role";

grant trigger on table "public"."mindmap_shares" to "service_role";

grant truncate on table "public"."mindmap_shares" to "service_role";

grant update on table "public"."mindmap_shares" to "service_role";

create policy "service role can do anything"
on "public"."mindmap_shares"
as permissive
for all
to service_role
using (true);


create policy "users can delete their data"
on "public"."mindmap_shares"
as permissive
for delete
to authenticated
using (( SELECT (auth.uid() = mindmap_shares.shared_with)));


create policy "users can insert their data only"
on "public"."mindmap_shares"
as permissive
for insert
to authenticated
with check (( SELECT (auth.uid() = mindmap_shares.shared_with)));


create policy "users can read their data"
on "public"."mindmap_shares"
as permissive
for select
to authenticated
using (( SELECT (auth.uid() = mindmap_shares.shared_with)));


create policy "users can view their data and published / admin view all "
on "public"."mindmaps"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) = author_id) OR (( SELECT user_roles.user_role
   FROM user_roles
  WHERE (user_roles.user_id = ( SELECT auth.uid() AS uid))) = 'ADMIN'::user_role_types) OR (publishing_status = 'PUBLISHED'::publishing_status)));



